#!/usr/bin/env ts-node
/**
 * GitHub PR Automation for Refactor Results
 *
 * Creates a pull request with automated refactor suggestions
 * based on the analysis results from refactor-ci.ts
 *
 * Requires:
 *  - GitHub CLI (gh) installed and authenticated
 *  - GITHUB_TOKEN environment variable (in CI/CD)
 *
 * Usage:
 *   npm run create-refactor-pr -- --results refactor-results.json
 */

import * as fs from 'fs';
import * as path from 'path';
import { execSync } from 'child_process';
import type { RefactorOpportunity } from '../src/stores/refactorStore';

interface PROptions {
  results: string;
  branch?: string;
  title?: string;
  config?: string;
  dryRun?: boolean;
  verbose?: boolean;
}

interface PRConfig {
  branch?: string;
  title?: string;
  body?: string;
  baseBranch?: string;
  labels?: string[];
  assignees?: string[];
  reviewers?: string[];
}

interface RefactorResult {
  success: boolean;
  timestamp: string;
  projectPath: string;
  summary: {
    totalIssues: number;
    criticalIssues: number;
    highIssues: number;
    mediumIssues: number;
    lowIssues: number;
    categoryCounts: Record<string, number>;
  };
  opportunities: RefactorOpportunity[];
  config: any;
}

/**
 * Parse command line arguments
 */
function parseArgs(): PROptions {
  const args = process.argv.slice(2);
  const options: PROptions = {
    results: 'refactor-results.json',
  };

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    const next = args[i + 1];

    switch (arg) {
      case '--results':
      case '-r':
        options.results = next;
        i++;
        break;
      case '--branch':
      case '-b':
        options.branch = next;
        i++;
        break;
      case '--title':
      case '-t':
        options.title = next;
        i++;
        break;
      case '--config':
      case '-c':
        options.config = next;
        i++;
        break;
      case '--dry-run':
        options.dryRun = true;
        break;
      case '--verbose':
      case '-v':
        options.verbose = true;
        break;
      case '--help':
      case '-h':
        printHelp();
        process.exit(0);
    }
  }

  return options;
}

/**
 * Print help message
 */
function printHelp() {
  console.log(`
Vibeman Refactor PR Automation

Usage:
  npm run create-refactor-pr [options]

Options:
  -r, --results <file>      Path to refactor results JSON file
  -b, --branch <name>       Branch name for the PR (default: auto-generated)
  -t, --title <title>       PR title (default: auto-generated)
  -c, --config <file>       Configuration file path (.refactor-pr.json)
  --dry-run                 Show what would be done without creating PR
  -v, --verbose             Verbose output
  -h, --help                Show this help message

Examples:
  # Create PR from results
  npm run create-refactor-pr -- --results refactor-results.json

  # Custom branch and title
  npm run create-refactor-pr -- --results results.json --branch fix/refactor-improvements --title "Automated refactor improvements"

  # Dry run
  npm run create-refactor-pr -- --results results.json --dry-run
`);
}

/**
 * Load PR configuration
 */
function loadConfig(configPath?: string): PRConfig {
  const defaultConfigPath = path.join(process.cwd(), '.refactor-pr.json');
  const targetPath = configPath || defaultConfigPath;

  if (!fs.existsSync(targetPath)) {
    return {};
  }

  try {
    const content = fs.readFileSync(targetPath, 'utf-8');
    return JSON.parse(content);
  } catch (error) {
    console.error(`Error loading PR config from ${targetPath}:`, error);
    return {};
  }
}

/**
 * Load refactor results
 */
function loadResults(resultsPath: string): RefactorResult {
  if (!fs.existsSync(resultsPath)) {
    throw new Error(`Results file not found: ${resultsPath}`);
  }

  try {
    const content = fs.readFileSync(resultsPath, 'utf-8');
    return JSON.parse(content);
  } catch (error) {
    throw new Error(`Failed to parse results file: ${error}`);
  }
}

/**
 * Generate PR body from results
 */
function generatePRBody(result: RefactorResult): string {
  const { summary, opportunities } = result;

  let body = `## Automated Refactor Suggestions\n\n`;
  body += `This PR contains automated refactor suggestions generated by Vibeman Refactor CI.\n\n`;

  // Summary
  body += `### Summary\n\n`;
  body += `- **Total Issues**: ${summary.totalIssues}\n`;
  body += `- **Critical**: ${summary.criticalIssues}\n`;
  body += `- **High**: ${summary.highIssues}\n`;
  body += `- **Medium**: ${summary.mediumIssues}\n`;
  body += `- **Low**: ${summary.lowIssues}\n\n`;

  // Category breakdown
  if (Object.keys(summary.categoryCounts).length > 0) {
    body += `### Issues by Category\n\n`;
    Object.entries(summary.categoryCounts)
      .sort((a, b) => b[1] - a[1])
      .forEach(([category, count]) => {
        body += `- **${category}**: ${count}\n`;
      });
    body += `\n`;
  }

  // Group opportunities by severity
  const bySeverity = {
    critical: opportunities.filter(o => o.severity === 'critical'),
    high: opportunities.filter(o => o.severity === 'high'),
    medium: opportunities.filter(o => o.severity === 'medium'),
    low: opportunities.filter(o => o.severity === 'low'),
  };

  // List top issues
  const severityOrder: Array<keyof typeof bySeverity> = ['critical', 'high', 'medium', 'low'];
  for (const severity of severityOrder) {
    const items = bySeverity[severity];
    if (items.length === 0) continue;

    body += `### ${severity.charAt(0).toUpperCase() + severity.slice(1)} Priority Issues\n\n`;

    // Show first 5 items
    items.slice(0, 5).forEach((opp, index) => {
      body += `${index + 1}. **${opp.title}**\n`;
      body += `   - Category: ${opp.category}\n`;
      body += `   - Impact: ${opp.impact}\n`;
      body += `   - Effort: ${opp.effort}\n`;
      if (opp.estimatedTime) {
        body += `   - Estimated Time: ${opp.estimatedTime}\n`;
      }
      body += `   - Files: ${opp.files.join(', ')}\n`;
      body += `\n`;
    });

    if (items.length > 5) {
      body += `*...and ${items.length - 5} more ${severity} priority issues*\n\n`;
    }
  }

  // Footer
  body += `---\n\n`;
  body += `> Generated by [Vibeman Refactor CI](https://github.com/your-org/vibeman) on ${new Date(result.timestamp).toLocaleString()}\n`;

  return body;
}

/**
 * Execute git command
 */
function git(command: string, verbose: boolean = false): string {
  if (verbose) {
    console.log(`$ git ${command}`);
  }
  try {
    return execSync(`git ${command}`, { encoding: 'utf-8' }).trim();
  } catch (error) {
    throw new Error(`Git command failed: git ${command}`);
  }
}

/**
 * Execute gh (GitHub CLI) command
 */
function gh(command: string, verbose: boolean = false): string {
  if (verbose) {
    console.log(`$ gh ${command}`);
  }
  try {
    return execSync(`gh ${command}`, { encoding: 'utf-8' }).trim();
  } catch (error) {
    throw new Error(`GitHub CLI command failed: gh ${command}\n${error}`);
  }
}

/**
 * Check if gh CLI is installed and authenticated
 */
function checkGitHubCLI(verbose: boolean = false): boolean {
  try {
    const status = gh('auth status', verbose);
    return true;
  } catch (error) {
    return false;
  }
}

/**
 * Get current branch name
 */
function getCurrentBranch(verbose: boolean = false): string {
  return git('rev-parse --abbrev-ref HEAD', verbose);
}

/**
 * Main execution function
 */
async function main() {
  const options = parseArgs();
  const config = loadConfig(options.config);

  if (options.verbose) {
    console.log('Vibeman Refactor PR Automation');
    console.log('==============================');
    console.log('');
  }

  try {
    // Check GitHub CLI
    if (!checkGitHubCLI(options.verbose)) {
      throw new Error(
        'GitHub CLI (gh) is not installed or not authenticated.\n' +
        'Install: https://cli.github.com/\n' +
        'Authenticate: gh auth login'
      );
    }

    // Load results
    if (options.verbose) {
      console.log(`Loading results from: ${options.results}`);
    }
    const result = loadResults(options.results);

    if (!result.success) {
      throw new Error('Refactor analysis failed. Cannot create PR.');
    }

    if (result.summary.totalIssues === 0) {
      console.log('No issues found. Skipping PR creation.');
      process.exit(0);
    }

    // Generate branch name
    const timestamp = new Date().toISOString().split('T')[0].replace(/-/g, '');
    const defaultBranch = `refactor/automated-${timestamp}`;
    const branchName = options.branch || config.branch || defaultBranch;

    // Generate PR title
    const defaultTitle = `Automated Refactor: ${result.summary.totalIssues} improvements`;
    const prTitle = options.title || config.title || defaultTitle;

    // Generate PR body
    const prBody = generatePRBody(result);

    if (options.verbose) {
      console.log('');
      console.log('PR Details:');
      console.log(`  Branch: ${branchName}`);
      console.log(`  Title: ${prTitle}`);
      console.log('');
    }

    if (options.dryRun) {
      console.log('DRY RUN - Would create PR with:');
      console.log('');
      console.log('Branch:', branchName);
      console.log('Title:', prTitle);
      console.log('');
      console.log('Body:');
      console.log(prBody);
      process.exit(0);
    }

    // Get current branch
    const currentBranch = getCurrentBranch(options.verbose);
    const baseBranch = config.baseBranch || 'main';

    if (options.verbose) {
      console.log(`Current branch: ${currentBranch}`);
      console.log(`Base branch: ${baseBranch}`);
      console.log('');
    }

    // Create new branch if needed
    if (currentBranch !== branchName) {
      if (options.verbose) {
        console.log(`Creating new branch: ${branchName}`);
      }
      git(`checkout -b ${branchName}`, options.verbose);
    }

    // Check if there are changes to commit
    const status = git('status --porcelain', options.verbose);
    if (!status) {
      console.log('No changes to commit. Skipping PR creation.');
      process.exit(0);
    }

    // Stage and commit changes
    if (options.verbose) {
      console.log('Staging and committing changes...');
    }
    git('add .', options.verbose);
    git(`commit -m "chore: automated refactor suggestions (${result.summary.totalIssues} issues)"`, options.verbose);

    // Push branch
    if (options.verbose) {
      console.log(`Pushing branch: ${branchName}`);
    }
    git(`push -u origin ${branchName}`, options.verbose);

    // Create PR using GitHub CLI
    if (options.verbose) {
      console.log('Creating pull request...');
    }

    let ghCommand = `pr create --base ${baseBranch} --head ${branchName} --title "${prTitle}" --body "${prBody.replace(/"/g, '\\"')}"`;

    // Add labels
    if (config.labels && config.labels.length > 0) {
      ghCommand += ` --label "${config.labels.join(',')}"`;
    }

    // Add reviewers
    if (config.reviewers && config.reviewers.length > 0) {
      ghCommand += ` --reviewer "${config.reviewers.join(',')}"`;
    }

    // Add assignees
    if (config.assignees && config.assignees.length > 0) {
      ghCommand += ` --assignee "${config.assignees.join(',')}"`;
    }

    const prUrl = gh(ghCommand, options.verbose);

    console.log('');
    console.log(' Pull request created successfully!');
    console.log(`   ${prUrl}`);
    console.log('');

    process.exit(0);
  } catch (error) {
    console.error('L Error:', error instanceof Error ? error.message : String(error));
    process.exit(1);
  }
}

// Run if executed directly
if (require.main === module) {
  main();
}

export { main, parseArgs, loadConfig, generatePRBody };
