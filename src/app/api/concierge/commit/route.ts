/**
 * Commit Generated Code API
 * Commits generated code to the repository
 */

import { NextRequest, NextResponse } from 'next/server';
import { featureRequestDb, eventDb } from '@/app/db';
import { v4 as uuidv4 } from 'uuid';
import { promises as fs } from 'fs';
import path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

interface CommitCodeRequest {
  requestId: string;
  projectPath: string;
  autoCommit?: boolean;
  commitMessage?: string;
}

/**
 * POST - Commit generated code to repository
 */
export async function POST(request: NextRequest) {
  try {
    const body: CommitCodeRequest = await request.json();
    const { requestId, projectPath, autoCommit = false, commitMessage } = body;

    // Validate required fields
    if (!requestId || !projectPath) {
      return NextResponse.json(
        { error: 'requestId and projectPath are required' },
        { status: 400 }
      );
    }

    // Get the feature request
    const featureRequest = featureRequestDb.getById(requestId);
    if (!featureRequest) {
      return NextResponse.json(
        { error: 'Feature request not found' },
        { status: 404 }
      );
    }

    // Check if code has been generated
    if (featureRequest.status !== 'code_generated') {
      return NextResponse.json(
        { error: 'Code has not been generated yet' },
        { status: 400 }
      );
    }

    // Parse generated code
    const generatedCode = JSON.parse(featureRequest.generated_code || '[]');
    const generatedTests = JSON.parse(featureRequest.generated_tests || '[]');

    if (generatedCode.length === 0) {
      return NextResponse.json(
        { error: 'No generated code to commit' },
        { status: 400 }
      );
    }

    try {
      // Write files to disk
      const writtenFiles: string[] = [];
      const modifiedFiles: string[] = [];
      const deletedFiles: string[] = [];

      for (const file of generatedCode) {
        const filePath = path.join(projectPath, file.file_path);

        if (file.action === 'delete') {
          try {
            await fs.unlink(filePath);
            deletedFiles.push(file.file_path);
          } catch (error) {
            // Could not delete file - may not exist
          }
        } else {
          // Ensure directory exists
          const dir = path.dirname(filePath);
          await fs.mkdir(dir, { recursive: true });

          // Check if file exists to determine if it's create or modify
          const exists = await fs.access(filePath).then(() => true).catch(() => false);

          // Write file
          await fs.writeFile(filePath, file.content, 'utf-8');

          if (exists || file.action === 'modify') {
            modifiedFiles.push(file.file_path);
          } else {
            writtenFiles.push(file.file_path);
          }
        }
      }

      // Write test files
      for (const test of generatedTests) {
        const testPath = path.join(projectPath, test.file_path);
        const dir = path.dirname(testPath);
        await fs.mkdir(dir, { recursive: true });
        await fs.writeFile(testPath, test.content, 'utf-8');
        writtenFiles.push(test.file_path);
      }

      // Auto-commit if requested
      let commitSha: string | undefined;
      let commitUrl: string | undefined;

      if (autoCommit) {
        const defaultMessage = `feat: ${featureRequest.natural_language_description.substring(0, 50)}

Generated by AI Code Concierge
Requested by: ${featureRequest.requester_name}

Files created: ${writtenFiles.length}
Files modified: ${modifiedFiles.length}
Files deleted: ${deletedFiles.length}

Generated with Claude Code (https://claude.com/claude-code)
Co-Authored-By: Claude <noreply@anthropic.com>`;

        const finalMessage = commitMessage || defaultMessage;

        try {
          // Stage all changes
          const allFiles = [...writtenFiles, ...modifiedFiles, ...deletedFiles];
          for (const file of allFiles) {
            await execAsync(`git add "${file}"`, { cwd: projectPath });
          }

          // Commit
          await execAsync(`git commit -m "${finalMessage.replace(/"/g, '\\"')}"`, { cwd: projectPath });

          // Get commit SHA
          const { stdout: shaOutput } = await execAsync('git rev-parse HEAD', { cwd: projectPath });
          commitSha = shaOutput.trim();

          // Try to get remote URL for commit URL
          try {
            const { stdout: remoteOutput } = await execAsync('git remote get-url origin', { cwd: projectPath });
            const remoteUrl = remoteOutput.trim();

            // Convert git URL to web URL (basic implementation)
            if (remoteUrl.includes('github.com')) {
              const match = remoteUrl.match(/github\.com[:/](.+?)\.git/);
              if (match) {
                commitUrl = `https://github.com/${match[1]}/commit/${commitSha}`;
              }
            }
          } catch (error) {
            // Could not get remote URL
          }
        } catch (error) {
          // Git commit failed - continue with file operations
        }
      }

      // Update feature request status
      featureRequestDb.update(requestId, {
        status: autoCommit ? 'committed' : 'code_generated',
        commit_sha: commitSha,
        commit_url: commitUrl,
      });

      // Log success event
      eventDb.createEvent({
        id: uuidv4(),
        project_id: featureRequest.project_id,
        title: autoCommit ? 'Code Committed' : 'Code Written to Disk',
        description: `${writtenFiles.length} created, ${modifiedFiles.length} modified, ${deletedFiles.length} deleted`,
        type: 'success',
        agent: 'concierge',
        message: autoCommit ? `Committed as ${commitSha}` : 'Files written successfully',
      });

      return NextResponse.json({
        success: true,
        data: {
          writtenFiles,
          modifiedFiles,
          deletedFiles,
          commitSha,
          commitUrl,
          autoCommitted: autoCommit,
        },
      });
    } catch (error) {
      // Update status to failed
      featureRequestDb.update(requestId, {
        status: 'failed',
        error_message: error instanceof Error ? error.message : 'Unknown error during commit',
      });

      // Log error event
      eventDb.createEvent({
        id: uuidv4(),
        project_id: featureRequest.project_id,
        title: 'Code Commit Failed',
        description: error instanceof Error ? error.message : 'Unknown error',
        type: 'error',
        agent: 'concierge',
        message: 'Failed to write or commit generated code',
      });

      throw error;
    }
  } catch (error) {
    return NextResponse.json(
      {
        error: 'Failed to commit code',
        details: error instanceof Error ? error.message : 'Unknown error',
      },
      { status: 500 }
    );
  }
}
