import { NextRequest, NextResponse } from 'next/server';
import * as fs from 'fs/promises';
import * as path from 'path';

/**
 * POST /api/unused-code/save-report
 *
 * Saves unused code scan results to a markdown file
 *
 * Request body:
 * {
 *   projectPath: string;
 *   projectName: string;
 *   unusedFiles: Array<{ relativePath: string; exports: string[] }>;
 *   stats: { totalFiles: number; totalExports: number; unusedExports: number };
 * }
 */
export async function POST(request: NextRequest) {
  try {
    const { projectPath, projectName, unusedFiles, stats } = await request.json();

    if (!projectPath || !projectName) {
      return NextResponse.json(
        { success: false, error: 'projectPath and projectName are required' },
        { status: 400 }
      );
    }

    // Create docs/unused directory if it doesn't exist
    const docsDir = path.join(projectPath, 'docs');
    const unusedDir = path.join(docsDir, 'unused');

    try {
      await fs.mkdir(docsDir, { recursive: true });
      await fs.mkdir(unusedDir, { recursive: true });
    } catch (error) {
      // Directory creation failed
      return NextResponse.json(
        { success: false, error: 'Failed to create output directory' },
        { status: 500 }
      );
    }

    // Generate filename with timestamp
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
    const filename = `unused-code-scan-${timestamp}.md`;
    const filePath = path.join(unusedDir, filename);

    // Generate markdown content
    const markdown = generateMarkdownReport(projectName, unusedFiles, stats, timestamp);

    // Write file
    await fs.writeFile(filePath, markdown, 'utf-8');

    return NextResponse.json({
      success: true,
      filePath: filePath,
      relativePath: path.join('docs', 'unused', filename),
    });
  } catch (error) {
    // Report saving failed
    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to save report',
      },
      { status: 500 }
    );
  }
}

/**
 * Generate markdown report from scan results
 */
function generateMarkdownReport(
  projectName: string,
  unusedFiles: Array<{ relativePath: string; exports: string[]; reason?: string }>,
  stats: { totalFiles: number; totalExports: number; unusedExports: number },
  timestamp: string
): string {
  const lines: string[] = [];

  // Header
  lines.push(`# Unused Code Scan Report`);
  lines.push(``);
  lines.push(`**Project:** ${projectName}`);
  lines.push(`**Scan Date:** ${new Date(timestamp).toLocaleString()}`);
  lines.push(`**Generated by:** Vibeman Blueprint Scanner`);
  lines.push(``);
  lines.push(`---`);
  lines.push(``);

  // Summary
  lines.push(`## Summary`);
  lines.push(``);
  lines.push(`- **Total component files analyzed:** ${stats.totalFiles}`);
  lines.push(`- **Total exports found:** ${stats.totalExports}`);
  lines.push(`- **Unused files detected:** ${unusedFiles.length}`);
  lines.push(`- **Unused exports:** ${stats.unusedExports}`);
  lines.push(``);

  if (unusedFiles.length === 0) {
    lines.push(`✅ **No unused code detected!** Your project is clean.`);
    lines.push(``);
  } else {
    const unusedPercentage = ((unusedFiles.length / stats.totalFiles) * 100).toFixed(1);
    lines.push(`⚠️ **${unusedPercentage}% of component files appear to be unused.**`);
    lines.push(``);
  }

  lines.push(`---`);
  lines.push(``);

  // Detection Method
  lines.push(`## Detection Method`);
  lines.push(``);
  lines.push(`This scan searches for component usage in two ways:`);
  lines.push(``);
  lines.push(`1. **JSX Tags**: Searches for \`<ComponentName>\` in all files`);
  lines.push(`2. **Imports**: Searches for \`import ComponentName\` or \`import { ComponentName }\``);
  lines.push(``);
  lines.push(`### Limitations`);
  lines.push(``);
  lines.push(`- May miss dynamically generated component names`);
  lines.push(`- May miss components used via string references`);
  lines.push(`- Focuses on .tsx files only (UI components)`);
  lines.push(`- Excludes API routes, utilities, types, and services`);
  lines.push(``);
  lines.push(`### Recommendation`);
  lines.push(``);
  lines.push(`⚠️ **Always review manually before removing any files.** This is a static analysis tool and may produce false positives.`);
  lines.push(``);

  // Unused Files List
  if (unusedFiles.length > 0) {
    lines.push(`---`);
    lines.push(``);
    lines.push(`## Unused Files (${unusedFiles.length})`);
    lines.push(``);

    unusedFiles.forEach((file, index) => {
      lines.push(`### ${index + 1}. \`${file.relativePath}\``);
      lines.push(``);
      lines.push(`- **Exports:** ${file.exports.map(e => `\`${e}\``).join(', ')}`);
      if (file.reason) {
        lines.push(`- **Reason:** ${file.reason}`);
      }
      lines.push(``);
    });
  }

  // Footer
  lines.push(`---`);
  lines.push(``);
  lines.push(`## Next Steps`);
  lines.push(``);
  lines.push(`1. Review each file manually to confirm it's truly unused`);
  lines.push(`2. Check for dynamic imports or runtime-only usage`);
  lines.push(`3. Consider archiving instead of deleting (e.g., move to \`archive/\` folder)`);
  lines.push(`4. Run tests after removing files to ensure nothing breaks`);
  lines.push(``);
  lines.push(`---`);
  lines.push(``);
  lines.push(`*Report generated by Vibeman Blueprint Scanner - ${timestamp}*`);

  return lines.join('\n');
}
