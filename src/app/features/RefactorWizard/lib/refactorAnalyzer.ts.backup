/**
 * Main analyzer that orchestrates file scanning, pattern detection, and AI analysis
 */
import type { RefactorOpportunity } from '@/stores/refactorStore';
import { scanProjectFiles } from './fileScanner';
import {
  detectDuplication,
  detectLongFunctions,
  detectConsoleStatements,
  detectAnyTypes,
  detectUnusedImports,
} from './patternDetectors';
import { analyzeWithAI, deduplicateOpportunities } from './aiAnalyzer';
import type { FileAnalysis, AnalysisResult } from './types';

// Re-export types and functions for backward compatibility
export { scanProjectFiles } from './fileScanner';
export { analyzeWithAI } from './aiAnalyzer';
export type { FileAnalysis, AnalysisResult } from './types';

/**
 * Helper: Create a refactor opportunity
 */
function createOpportunity(
  id: string,
  title: string,
  description: string,
  category: string,
  severity: string,
  impact: string,
  effort: string,
  files: string[],
  autoFixAvailable: boolean,
  estimatedTime: string,
  lineNumbers?: Record<string, number[]>
): RefactorOpportunity {
  return {
    id,
    title,
    description,
    category,
    severity,
    impact,
    effort,
    files,
    autoFixAvailable,
    estimatedTime,
    ...(lineNumbers && { lineNumbers }),
  };
}

/**
 * Check for large file size
 */
function checkLargeFile(file: FileAnalysis): RefactorOpportunity | null {
  if (file.lines <= 500) return null;

  return createOpportunity(
    `long-file-${file.path}`,
    `Large file detected: ${file.path}`,
    `This file has ${file.lines} lines. Consider splitting it into smaller, more focused modules.`,
    'maintainability',
    file.lines > 1000 ? 'high' : 'medium',
    'Improves code organization and maintainability',
    'high',
    [file.path],
    false,
    '2-4 hours'
  );
}

/**
 * Check for code duplication
 */
function checkDuplication(file: FileAnalysis): RefactorOpportunity | null {
  const duplicatePatterns = detectDuplication(file.content);
  if (duplicatePatterns.length === 0) return null;

  return {
    id: `duplication-${file.path}`,
    title: `Code duplication in ${file.path}`,
    description: `Found ${duplicatePatterns.length} duplicated code blocks that could be extracted into reusable functions.`,
    category: 'duplication',
    severity: 'medium',
    impact: 'Reduces code duplication and improves maintainability',
    effort: 'medium',
    files: [file.path],
    autoFixAvailable: true,
    estimatedTime: '1-2 hours',
  };
}

/**
 * Check for long functions
 */
function checkLongFunctions(file: FileAnalysis): RefactorOpportunity | null {
  const longFunctions = detectLongFunctions(file.content);
  if (longFunctions.length === 0) return null;

  return {
    id: `long-functions-${file.path}`,
    title: `Long functions in ${file.path}`,
    description: `Found ${longFunctions.length} functions exceeding 50 lines. Consider breaking them into smaller functions.`,
    category: 'maintainability',
    severity: 'low',
    impact: 'Improves code readability and testability',
    effort: 'medium',
    files: [file.path],
    lineNumbers: { [file.path]: longFunctions },
    autoFixAvailable: true,
    estimatedTime: '1-3 hours',
  };
}

/**
 * Check for console statements
 */
function checkConsoleStatements(file: FileAnalysis): RefactorOpportunity | null {
  const consoleStatements = detectConsoleStatements(file.content);
  if (consoleStatements.length === 0) return null;

  return {
    id: `console-logs-${file.path}`,
    title: `Console statements in ${file.path}`,
    description: `Found ${consoleStatements.length} console.log statements that should be removed or replaced with proper logging.`,
    category: 'code-quality',
    severity: 'low',
    impact: 'Cleaner production code',
    effort: 'low',
    files: [file.path],
    lineNumbers: { [file.path]: consoleStatements },
    autoFixAvailable: true,
    estimatedTime: '15-30 minutes',
  };
}

/**
 * Check for any type usage
 */
function checkAnyTypes(file: FileAnalysis): RefactorOpportunity | null {
  const anyTypes = detectAnyTypes(file.content);
  if (anyTypes.length === 0) return null;

  return {
    id: `any-types-${file.path}`,
    title: `'any' type usage in ${file.path}`,
    description: `Found ${anyTypes.length} uses of 'any' type. Consider using proper TypeScript types for better type safety.`,
    category: 'code-quality',
    severity: 'medium',
    impact: 'Improves type safety and prevents runtime errors',
    effort: 'medium',
    files: [file.path],
    lineNumbers: { [file.path]: anyTypes },
    autoFixAvailable: false,
    estimatedTime: '30-60 minutes',
  };
}

/**
 * Check for unused imports
 */
function checkUnusedImports(file: FileAnalysis): RefactorOpportunity | null {
  const unusedImports = detectUnusedImports(file.content);
  if (unusedImports.length === 0) return null;

  return {
    id: `unused-imports-${file.path}`,
    title: `Unused imports in ${file.path}`,
    description: `Found ${unusedImports.length} potentially unused imports that could be removed.`,
    category: 'code-quality',
    severity: 'low',
    impact: 'Cleaner code and smaller bundle size',
    effort: 'low',
    files: [file.path],
    autoFixAvailable: true,
    estimatedTime: '10-15 minutes',
  };
}

/**
 * Map technique IDs to their detector functions
 */
const TECHNIQUE_DETECTORS: Record<string, (file: FileAnalysis) => RefactorOpportunity | null> = {
  'large-files': checkLargeFile,
  'code-duplication': checkDuplication,
  'long-functions': checkLongFunctions,
  'console-statements': checkConsoleStatements,
  'any-types': checkAnyTypes,
  'unused-imports': checkUnusedImports,
};

/**
 * Get enabled technique IDs from selected groups
 */
function getEnabledTechniques(selectedGroups: string[]): Set<string> {
  // Import at runtime to avoid circular dependencies
  const { SCAN_TECHNIQUE_GROUPS } = require('./scanTechniques');

  const enabledTechniques = new Set<string>();

  // If no groups selected, return empty set (nothing enabled)
  if (!selectedGroups || selectedGroups.length === 0) {
    return enabledTechniques;
  }

  // Get all techniques from selected groups
  SCAN_TECHNIQUE_GROUPS
    .filter((group: any) => selectedGroups.includes(group.id))
    .forEach((group: any) => {
      group.techniques.forEach((technique: any) => {
        enabledTechniques.add(technique.id);
      });
    });

  return enabledTechniques;
}

/**
 * Analyzes code for common refactor opportunities using pattern detection
 */
export function analyzeCodePatterns(
  files: FileAnalysis[],
  selectedGroups?: string[]
): RefactorOpportunity[] {
  const opportunities: RefactorOpportunity[] = [];

  // If selectedGroups is provided, filter techniques by selection
  let enabledTechniques: Set<string> | null = null;
  if (selectedGroups && selectedGroups.length > 0) {
    enabledTechniques = getEnabledTechniques(selectedGroups);

    // If no techniques enabled, return empty array
    if (enabledTechniques.size === 0) {
      return opportunities;
    }
  }

  for (const file of files) {
    // Build checks array based on enabled techniques
    const checks: (RefactorOpportunity | null)[] = [];

    // If no selection provided, run all checks (backward compatibility)
    if (!enabledTechniques) {
      checks.push(
        checkLargeFile(file),
        checkDuplication(file),
        checkLongFunctions(file),
        checkConsoleStatements(file),
        checkAnyTypes(file),
        checkUnusedImports(file)
      );
    } else {
      // Only run checks for enabled techniques
      for (const [techniqueId, detector] of Object.entries(TECHNIQUE_DETECTORS)) {
        if (enabledTechniques.has(techniqueId)) {
          checks.push(detector(file));
        }
      }
    }

    checks.forEach(opp => {
      if (opp) opportunities.push(opp);
    });
  }

  return opportunities;
}

/**
 * Combines pattern-based and AI analysis
 */
export async function analyzeProject(
  projectPath: string,
  useAI: boolean = true,
  provider?: string,
  model?: string,
  selectedGroups?: string[]
): Promise<AnalysisResult> {
  // Scan files
  const files = await scanProjectFiles(projectPath);

  // Pattern-based analysis (with optional group filtering)
  const patternOpportunities = analyzeCodePatterns(files, selectedGroups);

  // AI-based analysis (if enabled)
  let aiOpportunities: RefactorOpportunity[] = [];
  if (useAI && files.length > 0) {
    aiOpportunities = await analyzeWithAI(files, provider, model);
  }

  // Combine and deduplicate
  const allOpportunities = [...patternOpportunities, ...aiOpportunities];
  const uniqueOpportunities = deduplicateOpportunities(allOpportunities);

  // Generate summary
  const categoryCounts: Record<string, number> = {};
  uniqueOpportunities.forEach(opp => {
    categoryCounts[opp.category] = (categoryCounts[opp.category] || 0) + 1;
  });

  return {
    opportunities: uniqueOpportunities,
    summary: {
      totalFiles: files.length,
      totalLines: files.reduce((sum, f) => sum + f.lines, 0),
      issuesFound: uniqueOpportunities.length,
      categoryCounts,
    },
  };
}
