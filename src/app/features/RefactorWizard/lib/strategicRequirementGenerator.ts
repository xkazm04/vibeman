import { RefactoringPackage, ProjectContext, RefactorOpportunity } from './types';
import { RefactorOpportunity as StoreOpportunity } from '@/stores/refactorStore';

/**
 * Generate strategic requirement file content for a package
 * Note: projectContext is optional - if not provided, context sections will be skipped
 */
export function generateStrategicRequirement(
  pkg: RefactoringPackage,
  projectContext: ProjectContext | null,
  options: {
    projectName: string;
    executionOrder: number;
    totalPackages: number;
  }
): string {
  const { projectName, executionOrder, totalPackages } = options;

  // Build markdown content
  let content = '';

  // Header
  content += `# ${pkg.name}\n\n`;
  content += `> **ðŸ“¦ STRATEGIC REFACTORING PACKAGE**\n`;
  content += `> Category: ${pkg.category} | Impact: ${pkg.impact} | Effort: ${pkg.effort}\n`;
  content += `> Generated by Vibeman RefactorWizard\n\n`;
  content += `---\n\n`;

  // Strategic Goal
  content += `## Strategic Goal\n\n`;
  content += `${pkg.strategicGoal}\n\n`;
  content += `This package addresses **${pkg.issueCount} related issues** to systematically improve the codebase.\n\n`;
  if (pkg.scope === 'module' && pkg.modulePattern) {
    content += `**Scope**: ${pkg.modulePattern}\n\n`;
  }
  content += `---\n\n`;

  // Context from CLAUDE.md (only if available)
  if (projectContext) {
    content += `## Context from CLAUDE.md\n\n`;
    content += `**Project**: ${projectName}\n`;
    content += `**Project Type**: ${projectContext.projectType}\n`;
    content += `**Technology Stack**: ${projectContext.techStack.join(', ')}\n\n`;

    if (projectContext.architecture) {
      content += `### Architecture\n\n`;
      content += `${projectContext.architecture.slice(0, 800)}\n\n`;
    }

    if (projectContext.priorities.length > 0) {
      content += `### Priorities\n\n`;
      projectContext.priorities.slice(0, 5).forEach(priority => {
        content += `- ${priority}\n`;
      });
      content += `\n`;
    }

    if (projectContext.conventions.length > 0) {
      content += `### Code Conventions\n\n`;
      projectContext.conventions.slice(0, 8).forEach(convention => {
        content += `- ${convention}\n`;
      });
      content += `\n`;
    }

    content += `---\n\n`;
  } else {
    content += `## Project Context\n\n`;
    content += `**Project**: ${projectName}\n\n`;
    content += `> Note: Full project context from CLAUDE.md was not available during generation.\n`;
    content += `> Please refer to CLAUDE.md for project conventions and architecture details.\n\n`;
    content += `---\n\n`;
  }

  // Strategy
  content += `## ${pkg.strategy.type === 'migration' ? 'Migration' : 'Implementation'} Strategy\n\n`;
  content += `**Type**: ${pkg.strategy.type}\n\n`;
  content += `**Rationale**: ${pkg.strategy.rationale}\n\n`;
  content += `**Approach**: ${pkg.strategy.approach}\n\n`;

  if (pkg.expectedOutcomes.length > 0) {
    content += `### Expected Outcomes\n\n`;
    pkg.expectedOutcomes.forEach(outcome => {
      content += `- ${outcome}\n`;
    });
    content += `\n`;
  }

  content += `---\n\n`;

  // Dependencies
  content += `## Dependencies\n\n`;

  if (pkg.dependsOn.length > 0) {
    content += `**Prerequisites** (must complete before this package):\n`;
    content += `- This package has ${pkg.dependsOn.length} dependency/dependencies\n`;
    content += `- Ensure those packages are completed first\n\n`;
  } else {
    content += `**Prerequisites**: None (foundational package)\n\n`;
  }

  if (pkg.enables.length > 0) {
    content += `**Enables** (packages unblocked by completing this):\n`;
    content += `- This package unblocks ${pkg.enables.length} dependent package(s)\n\n`;
  }

  content += `**Execution Order**: ${executionOrder} of ${totalPackages} (lower = more foundational)\n\n`;
  content += `---\n\n`;

  // Implementation Plan
  content += `## Implementation Plan\n\n`;

  if (pkg.phases && pkg.phases.length > 0) {
    // Phase-based implementation
    content += `This package is organized into **${pkg.phases.length} phases** for systematic execution:\n\n`;

    pkg.phases.forEach((phase) => {
      content += `### ${phase.name}\n\n`;
      content += `${phase.description}\n\n`;
      content += `**Issues in this phase**: ${phase.opportunities.length}\n\n`;

      // Issues in phase
      phase.opportunities.forEach((opp, oppIndex) => {
        const issueNum = oppIndex + 1;
        content += formatOpportunity(opp, issueNum);
      });

      if (phase.dependsOnPhase) {
        content += `**Note**: Complete ${phase.dependsOnPhase} before starting this phase.\n\n`;
      }
    });
  } else {
    // Single-phase implementation
    content += `**Issues to Address** (${pkg.opportunities.length} total):\n\n`;

    pkg.opportunities.forEach((opp, index) => {
      const issueNum = index + 1;
      content += formatOpportunity(opp, issueNum);
    });
  }

  // Validation Criteria
  content += `## Validation Criteria\n\n`;
  content += `**Functional Requirements**:\n`;
  content += `- [ ] All ${pkg.issueCount} issues addressed\n`;
  content += `- [ ] Tests passing (\`npm test\`)\n`;
  content += `- [ ] Type checking passing (\`npx tsc --noEmit\`)\n`;
  content += `- [ ] No new linting errors\n`;
  content += `- [ ] Code review completed\n`;
  content += `- [ ] Changes committed with descriptive messages\n\n`;

  if (pkg.expectedOutcomes.length > 0) {
    content += `**Measurable Outcomes**:\n`;
    pkg.expectedOutcomes.forEach(outcome => {
      content += `- [ ] ${outcome}\n`;
    });
    content += `\n`;
  }

  content += `---\n\n`;

  // Completion Checklist
  content += `## Completion Checklist\n\n`;

  if (pkg.phases && pkg.phases.length > 0) {
    pkg.phases.forEach((phase) => {
      content += `- [ ] ${phase.name} completed (${phase.opportunities.length} issues)\n`;
    });
  } else {
    content += `- [ ] All ${pkg.issueCount} issues reviewed and addressed\n`;
  }

  content += `- [ ] All validation criteria met\n`;
  content += `- [ ] Documentation updated (if applicable)\n`;
  content += `- [ ] Stakeholders notified (if applicable)\n\n`;

  content += `---\n\n`;

  // Notes section
  content += `## Notes & Observations\n\n`;
  content += `[Space for Claude Code to add implementation notes, challenges encountered, deviations from plan]\n\n`;
  content += `---\n\n`;

  // Related Documentation
  if (pkg.relatedDocs && pkg.relatedDocs.length > 0) {
    content += `## Related Documentation\n\n`;
    pkg.relatedDocs.forEach(doc => {
      content += `- ${doc}\n`;
    });
    content += `\n---\n\n`;
  }

  // Metadata footer
  content += `**Package ID**: ${pkg.id}\n`;
  content += `**Estimated Time**: ${pkg.estimatedHours} hours\n`;
  content += `**Execution Order**: ${executionOrder} of ${totalPackages}\n`;
  content += `**Category**: ${pkg.category}\n`;
  content += `**Scope**: ${pkg.scope}\n`;

  return content;
}

/**
 * Format a single opportunity for the requirement file
 */
function formatOpportunity(opp: RefactorOpportunity, issueNum: number): string {
  let content = '';

  content += `#### ${issueNum}. ${opp.title}\n\n`;
  content += `**Category**: ${opp.category} | **Severity**: ${opp.severity} | **Effort**: ${opp.effort}\n\n`;

  if (opp.description) {
    content += `**Description**:\n${opp.description}\n\n`;
  }

  if (opp.impact) {
    content += `**Impact**:\n${opp.impact}\n\n`;
  }

  if (opp.files && opp.files.length > 0) {
    content += `**Files Affected**:\n`;
    opp.files.slice(0, 10).forEach(file => {
      content += `- \`${file}\`\n`;
    });
    if (opp.files.length > 10) {
      content += `- ... and ${opp.files.length - 10} more files\n`;
    }
    content += `\n`;
  }

  if (opp.lineNumbers && Object.keys(opp.lineNumbers).length > 0) {
    content += `**Line Numbers**:\n`;
    Object.entries(opp.lineNumbers).slice(0, 5).forEach(([file, lines]) => {
      if (Array.isArray(lines) && lines.length > 0) {
        content += `- ${file}: lines ${lines.join(', ')}\n`;
      }
    });
    content += `\n`;
  }

  if (opp.suggestedFix) {
    content += `**Suggested Fix**:\n\`\`\`\n${opp.suggestedFix}\n\`\`\`\n\n`;
  }

  if (opp.autoFixAvailable) {
    content += `âœ… **Auto-fix available**\n\n`;
  }

  content += `---\n\n`;

  return content;
}

/**
 * Generate filename slug from package name
 */
export function generatePackageSlug(packageName: string): string {
  return packageName
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-|-$/g, '');
}

/**
 * Generate a simple requirement file from a list of opportunities (no packaging)
 * Used for "skip packaging" mode where opportunities are batched directly
 */
export function generateSimpleRequirement(
  opportunities: StoreOpportunity[],
  options: {
    projectName: string;
    chunkIndex: number;
    totalChunks: number;
  }
): string {
  const { projectName, chunkIndex, totalChunks } = options;

  let content = '';

  // Header
  content += `# Refactoring Batch ${chunkIndex} of ${totalChunks}\n\n`;
  content += `> **ðŸ“‹ REFACTORING REQUIREMENT FILE**\n`;
  content += `> Project: ${projectName}\n`;
  content += `> Issues in this batch: ${opportunities.length}\n`;
  content += `> Generated by Vibeman RefactorWizard\n\n`;
  content += `---\n\n`;

  // Overview
  content += `## Overview\n\n`;
  content += `This batch contains **${opportunities.length} refactoring opportunities** to address.\n`;
  content += `Please work through each issue systematically, ensuring tests pass after each change.\n\n`;

  // Category breakdown
  const byCategory: Record<string, number> = {};
  const bySeverity: Record<string, number> = {};
  opportunities.forEach(opp => {
    byCategory[opp.category] = (byCategory[opp.category] || 0) + 1;
    bySeverity[opp.severity] = (bySeverity[opp.severity] || 0) + 1;
  });

  content += `### Summary\n\n`;
  content += `**By Category:**\n`;
  Object.entries(byCategory).forEach(([cat, count]) => {
    content += `- ${cat}: ${count}\n`;
  });
  content += `\n**By Severity:**\n`;
  Object.entries(bySeverity).forEach(([sev, count]) => {
    content += `- ${sev}: ${count}\n`;
  });
  content += `\n---\n\n`;

  // Issues
  content += `## Issues to Address\n\n`;

  opportunities.forEach((opp, index) => {
    const issueNum = index + 1;
    content += `### ${issueNum}. ${opp.title}\n\n`;
    content += `**Category**: ${opp.category} | **Severity**: ${opp.severity} | **Effort**: ${opp.effort}\n\n`;

    if (opp.description) {
      content += `**Description**:\n${opp.description}\n\n`;
    }

    if (opp.impact) {
      content += `**Impact**:\n${opp.impact}\n\n`;
    }

    if (opp.files && opp.files.length > 0) {
      content += `**Files Affected**:\n`;
      opp.files.slice(0, 10).forEach(file => {
        content += `- \`${file}\`\n`;
      });
      if (opp.files.length > 10) {
        content += `- ... and ${opp.files.length - 10} more files\n`;
      }
      content += `\n`;
    }

    if (opp.lineNumbers && Object.keys(opp.lineNumbers).length > 0) {
      content += `**Line Numbers**:\n`;
      Object.entries(opp.lineNumbers).slice(0, 5).forEach(([file, lines]) => {
        if (Array.isArray(lines) && lines.length > 0) {
          content += `- ${file}: lines ${lines.join(', ')}\n`;
        }
      });
      content += `\n`;
    }

    if (opp.suggestedFix) {
      content += `**Suggested Fix**:\n\`\`\`\n${opp.suggestedFix}\n\`\`\`\n\n`;
    }

    if (opp.autoFixAvailable) {
      content += `âœ… **Auto-fix available**\n\n`;
    }

    content += `---\n\n`;
  });

  // Validation
  content += `## Validation Checklist\n\n`;
  content += `- [ ] All ${opportunities.length} issues addressed\n`;
  content += `- [ ] Tests passing (\`npm test\`)\n`;
  content += `- [ ] Type checking passing (\`npx tsc --noEmit\`)\n`;
  content += `- [ ] No new linting errors\n`;
  content += `- [ ] Changes committed with descriptive messages\n\n`;

  content += `---\n\n`;
  content += `**Batch**: ${chunkIndex} of ${totalChunks}\n`;
  content += `**Total Issues**: ${opportunities.length}\n`;

  return content;
}
