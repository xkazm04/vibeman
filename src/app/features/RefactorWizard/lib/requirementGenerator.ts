interface Opportunity {
  id: string;
  title: string;
  description: string;
  category: string;
  severity: string;
  effort: string;
  impact: string;
  files: string[];
  lineNumbers?: Record<string, number[]>;
  suggestedFix?: string;
  estimatedTime?: string;
  autoFixAvailable?: boolean;
  /** Clean architecture principle from RefactorSuggestion integration */
  cleanArchitecturePrinciple?: string;
  /** Refactor steps from RefactorSuggestion integration */
  refactorSteps?: string[];
}

function generateHeader(projectName: string, batchNum: number, totalBatches: number, batchLength: number): string {
  return `# Refactoring Tasks - Batch ${batchNum} of ${totalBatches}

> **⚠️ AUTOMATED REFACTORING BATCH**
> This requirement was generated by the Vibeman Refactor Wizard as part of an automated code improvement process.

## Context

Project: **${projectName}**
Total issues in this batch: **${batchLength}**

## Instructions

This batch contains ${batchLength} refactoring opportunities identified through automated analysis. Please review each issue and implement the suggested fixes.

**Important guidelines:**
- Review each change carefully before implementing
- Run tests after each logical group of changes
- Commit changes incrementally with descriptive messages
- If an issue is not applicable or incorrect, document why and skip it

---

## Issues to Address

`;
}

/**
 * Helper: Format opportunity metadata
 */
function formatOpportunityMetadata(opp: Opportunity): string {
  return `**Category:** ${opp.category}
**Severity:** ${opp.severity}
**Effort:** ${opp.effort}
${opp.estimatedTime ? `**Estimated Time:** ${opp.estimatedTime}` : ''}`;
}

/**
 * Helper: Format line numbers section
 */
function formatLineNumbers(lineNumbers: Record<string, number[]>): string {
  return `**Line Numbers:**
${Object.entries(lineNumbers).map(([file, lines]) => `- ${file}: lines ${lines.join(', ')}`).join('\n')}

`;
}

/**
 * Helper: Format suggested fix section
 */
function formatSuggestedFix(suggestedFix: string): string {
  return `**Suggested Fix:**
\`\`\`
${suggestedFix}
\`\`\`

`;
}

/**
 * Helper: Format clean architecture metadata section
 * Requirements: 1.4 - Include clean architecture principles and refactor steps
 */
function formatCleanArchitectureMetadata(
  principle?: string,
  steps?: string[]
): string {
  let section = '';

  if (principle) {
    section += `**Clean Architecture Principle:**
${principle}

`;
  }

  if (steps && steps.length > 0) {
    section += `**Refactor Steps:**
${steps.map((step, i) => `${i + 1}. ${step}`).join('\n')}

`;
  }

  return section;
}

function generateOpportunitySection(opp: Opportunity, index: number): string {
  let section = `### ${index + 1}. ${opp.title}

${formatOpportunityMetadata(opp)}

**Description:**
${opp.description}

**Impact:**
${opp.impact}

**Files Affected:**
${opp.files.map(f => `- \`${f}\``).join('\n')}

`;

  if (opp.lineNumbers) {
    section += formatLineNumbers(opp.lineNumbers);
  }

  // Include clean architecture metadata if available (Requirements: 1.4)
  if (opp.cleanArchitecturePrinciple || (opp.refactorSteps && opp.refactorSteps.length > 0)) {
    section += formatCleanArchitectureMetadata(opp.cleanArchitecturePrinciple, opp.refactorSteps);
  }

  if (opp.suggestedFix) {
    section += formatSuggestedFix(opp.suggestedFix);
  }

  if (opp.autoFixAvailable) {
    section += '✅ **Auto-fix available** - This issue can be automatically resolved.\n\n';
  }

  section += '---\n\n';
  return section;
}

function generateFooter(batchLength: number): string {
  return `
## Completion Checklist

- [ ] All ${batchLength} issues reviewed
- [ ] Applicable fixes implemented
- [ ] Tests passing
- [ ] Code committed with descriptive messages
- [ ] Any skipped issues documented with reasoning

## Notes

Add any notes, observations, or blockers encountered during implementation here.
`;
}

export function generateRequirementContent(
  batch: Opportunity[],
  batchNum: number,
  totalBatches: number,
  projectName: string
): string {
  let content = generateHeader(projectName, batchNum, totalBatches, batch.length);

  // Add each opportunity with details
  batch.forEach((opp, index) => {
    content += generateOpportunitySection(opp, index);
  });

  content += generateFooter(batch.length);

  return content;
}
