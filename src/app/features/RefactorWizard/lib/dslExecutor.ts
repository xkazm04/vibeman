/**
 * DSL Executor
 *
 * Transforms RefactorSpec into Claude Code requirements and executes them
 * autonomously with test, commit, and rollback capabilities.
 */

import {
  RefactorSpec,
  TransformationRule,
  ExecutionResult,
  TransformationResult,
  TransformationPreview,
} from './dslTypes';

// ============================================================================
// REQUIREMENT GENERATION
// ============================================================================

/**
 * Generate a Claude Code requirement from a RefactorSpec
 */
export function generateRequirementFromSpec(spec: RefactorSpec): string {
  let content = '';

  // Header
  content += `# ${spec.name}\n\n`;
  content += `> **ðŸ”§ DSL-GENERATED REFACTORING REQUIREMENT**\n`;
  content += `> Mode: ${spec.execution?.mode || 'preview'} | Rules: ${spec.transformations.length}\n`;
  content += `> Generated by Vibeman RefactorWizard DSL\n\n`;
  content += `---\n\n`;

  // Overview
  content += `## Overview\n\n`;
  content += `${spec.description || 'Automated refactoring based on declarative specification.'}\n\n`;
  content += `This requirement contains **${spec.transformations.length} transformation rule(s)** `;
  content += `to be applied systematically across the codebase.\n\n`;
  content += `---\n\n`;

  // Scope
  content += `## Scope\n\n`;
  content += `**Include Patterns**:\n`;
  spec.scope.include.forEach(pattern => {
    content += `- \`${pattern}\`\n`;
  });
  content += `\n`;

  if (spec.scope.exclude && spec.scope.exclude.length > 0) {
    content += `**Exclude Patterns**:\n`;
    spec.scope.exclude.forEach(pattern => {
      content += `- \`${pattern}\`\n`;
    });
    content += `\n`;
  }

  if (spec.scope.fileTypes && spec.scope.fileTypes.length > 0) {
    content += `**File Types**: ${spec.scope.fileTypes.join(', ')}\n\n`;
  }

  if (spec.scope.modules && spec.scope.modules.length > 0) {
    content += `**Target Modules**:\n`;
    spec.scope.modules.forEach(module => {
      content += `- \`${module}\`\n`;
    });
    content += `\n`;
  }

  content += `---\n\n`;

  // Transformation Rules
  content += `## Transformation Rules\n\n`;
  content += `Execute the following transformations in order:\n\n`;

  const enabledRules = spec.transformations.filter(r => r.enabled !== false);
  const sortedRules = [...enabledRules].sort((a, b) => (b.priority || 0) - (a.priority || 0));

  sortedRules.forEach((rule, index) => {
    content += formatTransformationRule(rule, index + 1);
  });

  content += `---\n\n`;

  // Execution Instructions
  content += `## Execution Instructions\n\n`;

  content += `### Execution Mode: ${(spec.execution?.mode || 'preview').toUpperCase()}\n\n`;

  if (spec.execution?.mode === 'preview') {
    content += `- **Preview Only**: Show what changes would be made without applying them\n`;
    content += `- List all files that would be modified\n`;
    content += `- Show before/after for each transformation\n`;
  } else if (spec.execution?.mode === 'apply') {
    content += `- **Apply with Confirmation**: Apply each transformation with manual confirmation\n`;
    content += `- Wait for user approval before each change\n`;
    content += `- Show diff before applying\n`;
  } else if (spec.execution?.mode === 'auto') {
    content += `- **Automatic Execution**: Apply all transformations automatically\n`;
    content += `- Run tests after each transformation\n`;
    content += `- Commit changes automatically\n`;
    content += `- Rollback on failure\n`;
  }

  content += `\n`;

  // Execution checklist
  content += `### Execution Checklist\n\n`;

  if (spec.execution?.runTestsAfterEach) {
    content += `- [ ] Run tests after each transformation (\`npm test\`)\n`;
  }
  if (spec.execution?.typeCheck) {
    content += `- [ ] Run type checking (\`npx tsc --noEmit\`)\n`;
  }
  if (spec.execution?.lint) {
    content += `- [ ] Run linting (\`npm run lint\`)\n`;
  }
  if (spec.execution?.commitAfterEach) {
    content += `- [ ] Commit after each transformation\n`;
    if (spec.execution.commitTemplate) {
      content += `  - Template: \`${spec.execution.commitTemplate}\`\n`;
    }
  }
  if (spec.execution?.stopOnError) {
    content += `- [ ] Stop execution on first error\n`;
  }

  content += `\n---\n\n`;

  // Validation
  content += `## Post-Execution Validation\n\n`;

  content += `After completing all transformations, verify:\n\n`;

  if (spec.validation?.runTests) {
    content += `- [ ] All tests pass (\`npm test\`)\n`;
  }
  if (spec.validation?.runTypeCheck) {
    content += `- [ ] Type checking passes (\`npx tsc --noEmit\`)\n`;
  }
  if (spec.validation?.runLint) {
    content += `- [ ] No linting errors (\`npm run lint\`)\n`;
  }
  if (spec.validation?.runBuild) {
    content += `- [ ] Production build succeeds (\`npm run build\`)\n`;
  }
  if (spec.validation?.customCommands) {
    content += `\n**Custom Validation Commands**:\n`;
    spec.validation.customCommands.forEach(cmd => {
      content += `- [ ] \`${cmd}\`\n`;
    });
  }
  if (spec.validation?.minCoverage) {
    content += `- [ ] Test coverage >= ${spec.validation.minCoverage}%\n`;
  }

  content += `\n---\n\n`;

  // Implementation Notes
  content += `## Implementation Notes\n\n`;

  content += `### Pattern Matching\n\n`;
  content += `When applying transformations:\n`;
  content += `1. Search for files matching the scope patterns\n`;
  content += `2. For each file, apply each transformation rule in priority order\n`;
  content += `3. Preserve formatting and indentation\n`;
  content += `4. Handle edge cases (comments, strings, etc.)\n\n`;

  content += `### Best Practices\n\n`;
  content += `- Make minimal, focused changes\n`;
  content += `- Preserve existing code style\n`;
  content += `- Update imports as needed\n`;
  content += `- Add necessary dependencies\n`;
  content += `- Handle file moves with import updates\n\n`;

  content += `---\n\n`;

  // Metadata
  content += `## Metadata\n\n`;
  content += `- **Spec Version**: ${spec.version}\n`;
  content += `- **Total Rules**: ${spec.transformations.length}\n`;
  content += `- **Enabled Rules**: ${enabledRules.length}\n`;
  content += `- **Execution Mode**: ${spec.execution?.mode || 'preview'}\n`;
  if (spec.metadata?.effort) {
    content += `- **Estimated Effort**: ${spec.metadata.effort}\n`;
  }
  if (spec.metadata?.riskLevel) {
    content += `- **Risk Level**: ${spec.metadata.riskLevel}\n`;
  }
  if (spec.metadata?.tags && spec.metadata.tags.length > 0) {
    content += `- **Tags**: ${spec.metadata.tags.join(', ')}\n`;
  }

  return content;
}

/**
 * Format a single transformation rule for the requirement
 */
function formatTransformationRule(rule: TransformationRule, index: number): string {
  let content = '';

  content += `### ${index}. ${rule.name}\n\n`;

  if (rule.description) {
    content += `${rule.description}\n\n`;
  }

  content += `**Type**: ${rule.type}\n`;
  content += `**Impact**: ${rule.impact || 'medium'}\n`;
  if (rule.priority) {
    content += `**Priority**: ${rule.priority}\n`;
  }
  content += `\n`;

  // Pattern
  content += `**Pattern** (${rule.pattern.type}):\n`;
  content += `\`\`\`\n${rule.pattern.match}\n\`\`\`\n\n`;

  if (rule.pattern.caseSensitive === false) {
    content += `- Case insensitive matching\n`;
  }
  if (rule.pattern.wholeWord) {
    content += `- Whole word matching\n`;
  }

  // Pattern context
  if (rule.pattern.context) {
    const ctx = rule.pattern.context;
    if (ctx.insideOf && ctx.insideOf.length > 0) {
      content += `- Must be inside: ${ctx.insideOf.join(', ')}\n`;
    }
    if (ctx.notInsideOf && ctx.notInsideOf.length > 0) {
      content += `- Must NOT be inside: ${ctx.notInsideOf.join(', ')}\n`;
    }
    if (ctx.requiredImports && ctx.requiredImports.length > 0) {
      content += `- Required imports: ${ctx.requiredImports.join(', ')}\n`;
    }
    if (ctx.filePattern) {
      content += `- File pattern: ${ctx.filePattern}\n`;
    }
  }

  content += `\n`;

  // Replacement
  if (rule.replacement) {
    if (rule.replacement.template) {
      content += `**Replacement**:\n`;
      content += `\`\`\`\n${rule.replacement.template}\n\`\`\`\n\n`;
    }

    if (rule.replacement.targetPath) {
      content += `**Target Path**: \`${rule.replacement.targetPath}\`\n\n`;
    }

    if (rule.replacement.newImport) {
      content += `**New Import Path**: \`${rule.replacement.newImport}\`\n\n`;
    }

    if (rule.replacement.addImports && rule.replacement.addImports.length > 0) {
      content += `**Add Imports**:\n`;
      rule.replacement.addImports.forEach(imp => {
        if (imp.default) {
          content += `- import ${imp.default} from '${imp.from}'\n`;
        }
        if (imp.named && imp.named.length > 0) {
          const typePrefix = imp.typeOnly ? 'type ' : '';
          content += `- import ${typePrefix}{ ${imp.named.join(', ')} } from '${imp.from}'\n`;
        }
      });
      content += `\n`;
    }

    if (rule.replacement.removeImports && rule.replacement.removeImports.length > 0) {
      content += `**Remove Imports**: ${rule.replacement.removeImports.join(', ')}\n\n`;
    }
  }

  // Conditions
  if (rule.conditions && rule.conditions.length > 0) {
    content += `**Conditions**:\n`;
    rule.conditions.forEach(cond => {
      const negation = cond.negate ? 'NOT ' : '';
      content += `- ${negation}${cond.type}: ${cond.value}\n`;
    });
    content += `\n`;
  }

  content += `---\n\n`;

  return content;
}

// ============================================================================
// REQUIREMENT FILE GENERATION
// ============================================================================

/**
 * Generate a unique requirement filename
 */
export function generateRequirementFilename(spec: RefactorSpec): string {
  const slug = spec.name
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-|-$/g, '');

  return `dsl-${slug}`;
}

/**
 * Split a large spec into multiple requirements (if needed)
 */
export function splitSpecIntoChunks(
  spec: RefactorSpec,
  maxRulesPerChunk: number = 10
): RefactorSpec[] {
  if (spec.transformations.length <= maxRulesPerChunk) {
    return [spec];
  }

  const chunks: RefactorSpec[] = [];
  const totalChunks = Math.ceil(spec.transformations.length / maxRulesPerChunk);

  for (let i = 0; i < totalChunks; i++) {
    const start = i * maxRulesPerChunk;
    const end = Math.min(start + maxRulesPerChunk, spec.transformations.length);
    const rules = spec.transformations.slice(start, end);

    chunks.push({
      ...spec,
      name: `${spec.name} (Part ${i + 1}/${totalChunks})`,
      description: `${spec.description || ''} (Part ${i + 1} of ${totalChunks})`,
      transformations: rules,
    });
  }

  return chunks;
}

// ============================================================================
// AUTONOMOUS EXECUTION
// ============================================================================

/**
 * Generate autonomous execution script for a spec
 * This creates a detailed step-by-step execution plan
 */
export function generateAutonomousExecutionPlan(spec: RefactorSpec): string {
  let plan = '';

  plan += `# Autonomous Execution Plan: ${spec.name}\n\n`;
  plan += `## Execution Pipeline\n\n`;

  const enabledRules = spec.transformations.filter(r => r.enabled !== false);
  const sortedRules = [...enabledRules].sort((a, b) => (b.priority || 0) - (a.priority || 0));

  plan += `\`\`\`mermaid\n`;
  plan += `graph TD\n`;
  plan += `    A[Start] --> B[Scan Files]\n`;
  plan += `    B --> C[Apply Transformations]\n`;

  if (spec.execution?.runTestsAfterEach) {
    plan += `    C --> D[Run Tests]\n`;
    plan += `    D -->|Pass| E[Commit Changes]\n`;
    plan += `    D -->|Fail| F[Rollback]\n`;
  } else {
    plan += `    C --> E[Commit Changes]\n`;
  }

  plan += `    E --> G[Validation]\n`;
  plan += `    G -->|Pass| H[Complete]\n`;
  plan += `    G -->|Fail| F[Rollback]\n`;
  plan += `\`\`\`\n\n`;

  // Step-by-step
  plan += `## Step-by-Step Execution\n\n`;

  plan += `### Step 1: Pre-Flight Checks\n`;
  plan += `\`\`\`bash\n`;
  plan += `# Ensure clean git state\n`;
  plan += `git status --porcelain\n\n`;
  plan += `# Create backup branch\n`;
  plan += `git checkout -b refactor-backup-$(date +%Y%m%d-%H%M%S)\n`;
  plan += `git checkout -\n\n`;
  plan += `# Verify tests pass before starting\n`;
  plan += `npm test\n`;
  plan += `\`\`\`\n\n`;

  plan += `### Step 2: Execute Transformations\n\n`;

  sortedRules.forEach((rule, index) => {
    plan += `#### Rule ${index + 1}: ${rule.name}\n\n`;
    plan += `**Action**: Apply ${rule.type} transformation\n\n`;
    plan += `\`\`\`bash\n`;
    plan += `# Find files matching pattern\n`;
    plan += `find . -type f \\( ${spec.scope.include.map(p => `-name "${p.replace('**/', '').replace('/*', '')}"`).join(' -o ')} \\)\n\n`;

    if (rule.type === 'find-replace' || rule.type === 'regex-replace') {
      plan += `# Apply transformation (conceptual)\n`;
      plan += `# Pattern: ${rule.pattern.match}\n`;
      plan += `# Replace: ${rule.replacement?.template || 'N/A'}\n`;
    }

    plan += `\`\`\`\n\n`;

    if (spec.execution?.runTestsAfterEach) {
      plan += `**Post-Rule Validation**:\n`;
      plan += `\`\`\`bash\n`;
      plan += `npm test\n`;
      if (spec.execution?.typeCheck) {
        plan += `npx tsc --noEmit\n`;
      }
      plan += `\`\`\`\n\n`;
    }

    if (spec.execution?.commitAfterEach) {
      const commitMsg = (spec.execution.commitTemplate || 'refactor: {{ruleName}}')
        .replace('{{ruleName}}', rule.name)
        .replace('{{ruleId}}', rule.id);
      plan += `**Commit**:\n`;
      plan += `\`\`\`bash\n`;
      plan += `git add .\n`;
      plan += `git commit -m "${commitMsg}"\n`;
      plan += `\`\`\`\n\n`;
    }
  });

  plan += `### Step 3: Final Validation\n\n`;
  plan += `\`\`\`bash\n`;
  if (spec.validation?.runTests) {
    plan += `npm test\n`;
  }
  if (spec.validation?.runTypeCheck) {
    plan += `npx tsc --noEmit\n`;
  }
  if (spec.validation?.runLint) {
    plan += `npm run lint\n`;
  }
  if (spec.validation?.runBuild) {
    plan += `npm run build\n`;
  }
  plan += `\`\`\`\n\n`;

  plan += `### Step 4: Cleanup\n\n`;
  plan += `\`\`\`bash\n`;
  plan += `# On success: delete backup branch\n`;
  plan += `git branch -D refactor-backup-*\n\n`;
  plan += `# On failure: restore from backup\n`;
  plan += `# git reset --hard refactor-backup-<timestamp>\n`;
  plan += `\`\`\`\n\n`;

  return plan;
}

// ============================================================================
// EXECUTION RESULT TRACKING
// ============================================================================

/**
 * Create initial execution result
 */
export function createInitialExecutionResult(spec: RefactorSpec): ExecutionResult {
  return {
    specName: spec.name,
    status: 'pending',
    transformations: spec.transformations.map(rule => ({
      ruleId: rule.id,
      ruleName: rule.name,
      filesAffected: [],
      changesCount: 0,
      status: 'pending',
    })),
    summary: {
      totalRules: spec.transformations.length,
      rulesApplied: 0,
      rulesFailed: 0,
      rulesSkipped: 0,
      filesModified: 0,
      linesChanged: 0,
    },
    startTime: new Date(),
  };
}

/**
 * Update execution result with new transformation result
 */
export function updateExecutionResult(
  result: ExecutionResult,
  ruleId: string,
  update: Partial<TransformationResult>
): ExecutionResult {
  const newTransformations = result.transformations.map(t =>
    t.ruleId === ruleId ? { ...t, ...update } : t
  );

  const completed = newTransformations.filter(t => t.status === 'completed');
  const failed = newTransformations.filter(t => t.status === 'failed');
  const skipped = newTransformations.filter(t => t.status === 'skipped');

  return {
    ...result,
    transformations: newTransformations,
    summary: {
      ...result.summary,
      rulesApplied: completed.length,
      rulesFailed: failed.length,
      rulesSkipped: skipped.length,
      filesModified: completed.reduce((sum, t) => sum + t.filesAffected.length, 0),
      linesChanged: completed.reduce((sum, t) => sum + t.changesCount, 0),
    },
  };
}
