import fs from 'fs/promises';
import path from 'path';
import { DevelopmentRequirement, ClaudeTask } from '../types/development';

export class FileSystemInterface {
  private readonly TASKS_DIR = '.claude-tasks';
  private readonly REQUIREMENTS_DIR = '.requirements';
  private readonly STATUS_FILE = '.claude-status.json';

  constructor(private projectRoot: string) {}

  async initialize(): Promise<void> {
    // Create necessary directories
    await this.ensureDirectory(path.join(this.projectRoot, this.TASKS_DIR));
    await this.ensureDirectory(path.join(this.projectRoot, this.REQUIREMENTS_DIR));
    
    // Initialize status file
    const statusPath = path.join(this.projectRoot, this.STATUS_FILE);
    try {
      await fs.access(statusPath);
    } catch {
      await fs.writeFile(statusPath, JSON.stringify({ lastCheck: new Date().toISOString() }));
    }
  }

  private async ensureDirectory(dirPath: string): Promise<void> {
    try {
      await fs.access(dirPath);
    } catch {
      await fs.mkdir(dirPath, { recursive: true });
    }
  }

  // Generate a clean, readable task filename
  private generateTaskFilename(task: ClaudeTask): string {
    const now = new Date();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    const datePrefix = `${month}${day}`;
    
    // Extract title from prompt for short title
    const promptLines = task.prompt.split('\n');
    let title = 'untitled';
    
    for (const line of promptLines) {
      if (line.includes('**Title:**')) {
        title = line.replace('**Title:**', '').trim();
        break;
      }
    }
    
    // Create short title: lowercase, no spaces, max 20 chars
    const shortTitle = title
      .toLowerCase()
      .replace(/[^a-z0-9]/g, '')
      .substring(0, 20);
    
    return `req-${datePrefix}-${shortTitle}.json`;
  }

  // Generate requirement specification file
  async createRequirement(requirement: DevelopmentRequirement): Promise<string> {
    const filename = `${requirement.id}.md`;
    const filepath = path.join(this.projectRoot, this.REQUIREMENTS_DIR, filename);
    
    const content = this.generateRequirementMarkdown(requirement);
    await fs.writeFile(filepath, content, 'utf-8');
    
    return filepath;
  }

  // Create Claude task file that CLI can pick up
  async createClaudeTask(task: ClaudeTask): Promise<string> {
    const filename = this.generateTaskFilename(task);
    const filepath = path.join(this.projectRoot, this.TASKS_DIR, filename);
    
    await fs.writeFile(filepath, JSON.stringify(task, null, 2), 'utf-8');
    
    return filepath;
  }

  // Watch for completed tasks
  async getCompletedTasks(): Promise<ClaudeTask[]> {
    const tasksDir = path.join(this.projectRoot, this.TASKS_DIR);
    const files = await fs.readdir(tasksDir);
    
    const completedTasks: ClaudeTask[] = [];
    
    for (const file of files) {
      if (file.endsWith('.completed.json')) {
        const filepath = path.join(tasksDir, file);
        const content = await fs.readFile(filepath, 'utf-8');
        const task = JSON.parse(content) as ClaudeTask;
        completedTasks.push(task);
      }
    }
    
    return completedTasks;
  }

  // Clean up processed tasks
  async cleanupTask(taskId: string): Promise<void> {
    const tasksDir = path.join(this.projectRoot, this.TASKS_DIR);
    const files = await fs.readdir(tasksDir);
    
    for (const file of files) {
      if (file.includes(taskId)) {
        await fs.unlink(path.join(tasksDir, file));
      }
    }
  }

  private generateRequirementMarkdown(requirement: DevelopmentRequirement): string {
    return `# Development Requirement: ${requirement.title}

## Overview
**ID:** ${requirement.id}
**Priority:** ${requirement.priority}
**Complexity:** ${requirement.estimatedComplexity}/10
**Project Path:** ${requirement.projectPath}

## Description
${requirement.description}

## Affected Files
${requirement.files.map(file => `- ${file}`).join('\n')}

## Implementation Guidelines
- Follow existing code patterns in the project
- Ensure TypeScript compatibility
- Add appropriate error handling
- Include tests if applicable
- Update documentation as needed

## Context
This requirement was generated by the NextJS Brain Project monitoring system.
Created: ${requirement.createdAt.toISOString()}
Updated: ${requirement.updatedAt.toISOString()}
`;
  }
}
